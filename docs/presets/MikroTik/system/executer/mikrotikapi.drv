<?php if (!defined('ENVIRONMENT')) exit('No direct script access allowed!\n');

	class Executer {
		
		/* HERE WILL BE `mikrotik` SECTION FROM `config.ini` FILE: */
		private $config = array();
		
		/* "LOGGER" CLASS LINK: */
		private $log	=	NULL;
	
		/* PRIVATE VARIABLES: */
		private $connected	= FALSE;
		private $socket;
		private $error_no;
		private $error_str;
		
		/* TEMPLATES FOR RULES: */
		private $template = array(
			'ADDRESS_LIST'	=>	array(
				"list"		=>	"ALLOW",
				"address"	=>	IP,
				"disabled"	=>	NULL,
				"comment"	=>	LOGIN

			),
			'ARP'			=>	array(
				"address"		=>	IP,
				"mac-address"	=>	NULL,
				"interface"		=>	NULL,
				"disabled"		=>	"no",
				"comment"		=>	LOGIN
			),
			'QUEUE'			=>	array(
				'name'					=> LOGIN,
				'target-addresses'		=> IP,
				'interface'				=> 'all',
				'parent'				=> 'none',
				'packet-marks'			=> NULL,
				'direction' 			=> 'both',
				'priority'				=> 8,
				'queue'					=> 'default-small/default-small',
				'limit-at'				=> NULL,
				'max-limit'				=> NULL,
				'burst-limit'			=> NULL,
				'burst-threshold'		=> NULL,
				'burst-time'			=> NULL,
				'total-queue'			=> 'default-small',
				'total-limit-at'		=> 0,
				'total-max-limit'		=> 0,
				'total-burst-limit' 	=> 0,
				'total-burst-threshold' => 0,
				'total-burst-time'		=> 0,
				'disabled'				=> "no"
			)
		);
		
		/* CLASS CONSTRUCTOR: */
		public function __construct($data) {
			foreach($data as $key => $value) {
				$this->$key = $value;
			}
			$this->log->message(__CLASS__, "MikroTik Command Executer loaded...", "debug");
		}

/* >> START MIKROTIK API ( http://wiki.mikrotik.com/wiki/API_PHP_class ): << */
	
		/* ENCODE LENGTH: */
		private function encode_length($length) {
			if ($length < 0x80) {
				$length = chr($length);
			} else if ($length < 0x4000) {
				$length |= 0x8000;
				$length = chr(($length >> 8) & 0xFF) . chr($length & 0xFF);
			} else if ($length < 0x200000) {
				$length |= 0xC00000;
				$length = chr(($length >> 16) & 0xFF) . chr(($length >> 8) & 0xFF) . chr($length & 0xFF);
			} else if ($length < 0x10000000) {
				$length |= 0xE0000000;
				$length = chr(($length >> 24) & 0xFF) . chr(($length >> 16) & 0xFF) . chr(($length >> 8) & 0xFF) . chr($length & 0xFF);
			} else if ($length >= 0x10000000)
				$length = chr(0xF0) . chr(($length >> 24) & 0xFF) . chr(($length >> 16) & 0xFF) . chr(($length >> 8) & 0xFF) . chr($length & 0xFF);
			return $length;
		}

		/* CONNECT TO MIKROTIK VIA API: */
		private function connect($ip, $port, $login, $password) {
			for ($ATTEMPT = 1; $ATTEMPT <= $this->config['attempts']; $ATTEMPT++) {
				$this->connected = FALSE;
				$this->log->message(__CLASS__, 'Connection attempt #' . $ATTEMPT . ' to ' . $ip . ':' . $port . '...', "api");
				if ($this->socket = @fsockopen($ip, $port, $this->error_no, $this->error_str, $this->config['timeout'])) {
					socket_set_timeout($this->socket, $this->config['timeout']);
					$this->write('/login');
					$RESPONSE = $this->read(FALSE);
					if ($RESPONSE[0] == '!done') {
						if (preg_match_all('/[^=]+/i', $RESPONSE[1], $MATCHES)) {
							if ($MATCHES[0][0] == 'ret' && strlen($MATCHES[0][1]) == 32) {
								$this->write('/login', FALSE);
								$this->write('=name=' . $login, FALSE);
								$this->write('=response=00' . md5(chr(0) . $password . pack('H*', $MATCHES[0][1])));
								$RESPONSE = $this->read(FALSE);
								if ($RESPONSE[0] == '!done') {
									$this->connected = TRUE;
									break;
								}
							}
						}
					}
					fclose($this->socket);
				}
				sleep($this->config['delay']);
			}
			if ($this->connected) {
				$this->log->message(__CLASS__, 'Connection with MikroTik via API is established...', "debug");
			} else {
				$this->log->message(__CLASS__, 'Cannot establish connection with MikroTik via API!', "error");
			}
			return $this->connected;
		}

		/* DISCONNECT FROM MIKROTIK: */
		private function disconnect() {
			fclose($this->socket);
			$this->connected = FALSE;
			$this->log->message(__CLASS__, 'Disconnected from MikroTik...', "api");
		}

		/* PARSE RESPONSE: */
		private function parse_response($response) {
			if (is_array($response)) {
				$PARSED      = array();
				$CURRENT     = NULL;
				$singlevalue = NULL;
				$count       = 0;
				foreach ($response as $x) {
					if (in_array($x, array('!fatal', '!re', '!trap'))) {
						if ($x == '!re') { $CURRENT =& $PARSED[]; }
						else $CURRENT =& $PARSED[$x][];
					} else if ($x != '!done') {
						if (preg_match_all('/[^=]+/i', $x, $MATCHES)) {
							if ($MATCHES[0][0] == 'ret') $singlevalue = $MATCHES[0][1];
							$CURRENT[$MATCHES[0][0]] = (isset($MATCHES[0][1]) ? $MATCHES[0][1] : '');
						}
					}
				}
				if (empty($PARSED) && !is_null($singlevalue)) $PARSED = $singlevalue;
				return $PARSED;
			} else return array();
		}

		/* PARSE RESPONSE FOR SMARTY: */
		private function parse_response4smarty($response) {
			if (is_array($response)) {
				$PARSED  = array();
				$CURRENT = NULL;
				$singlevalue = NULL;
				foreach ($response as $x) {
					if (in_array($x, array('!fatal', '!re', '!trap' ))) {
						if ($x == '!re') $CURRENT =& $PARSED[];
						else $CURRENT =& $PARSED[$x][];
					} else if ($x != '!done') {
						if (preg_match_all('/[^=]+/i', $x, $MATCHES)) {
							if ($MATCHES[0][0] == 'ret') $singlevalue = $MATCHES[0][1];
							$CURRENT[$MATCHES[0][0]] = (isset($MATCHES[0][1]) ? $MATCHES[0][1] : '');
						}
					}
				}
				foreach ($PARSED as $key => $value) $PARSED[$key] = $this->array_change_key_name($value);
				return $PARSED;
				if (empty($PARSED) && !is_null($singlevalue)) $PARSED = $singlevalue;
			} else return array();
		}

		/* ARRAY CHANGE KEY NAME: */
		private function array_change_key_name(&$array) {
			if (is_array($array)) {
				foreach ($array as $key => $value) {
					$tmp = str_replace("-", "_", $key);
					$tmp = str_replace("/", "_", $tmp);
					if ($tmp) {
						$array_new[$tmp] = $value;
					} else {
						$array_new[$key] = $value;
					}
				}
				return $array_new;
			} else {
				return $array;
			}
		}

		/* READ: */
		private function read($parse = TRUE) {
			$RESPONSE = array();
			while (TRUE) {
				$BYTE   = ord(fread($this->socket, 1));
				$LENGTH = 0;
				if ($BYTE & 128) {
					if (($BYTE & 192) == 128) {
						$LENGTH = (($BYTE & 63) << 8) + ord(fread($this->socket, 1));
					} else {
						if (($BYTE & 224) == 192) {
							$LENGTH = (($BYTE & 31) << 8) + ord(fread($this->socket, 1));
							$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
						} else {
							if (($BYTE & 240) == 224) {
								$LENGTH = (($BYTE & 15) << 8) + ord(fread($this->socket, 1));
								$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
								$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
							} else {
								$LENGTH = ord(fread($this->socket, 1));
								$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
								$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
								$LENGTH = ($LENGTH << 8) + ord(fread($this->socket, 1));
							}
						}
					}
				} else {
					$LENGTH = $BYTE;
				}
				if ($LENGTH > 0) {
					$_      = "";
					$retlen = 0;
					while ($retlen < $LENGTH) {
						$toread = $LENGTH - $retlen;
						$_ .= fread($this->socket, $toread);
						$retlen = strlen($_);
					}
					$RESPONSE[] = $_;
					$this->log->message(__CLASS__, '>>> [' . $retlen . '/' . $LENGTH . '] bytes read.', "api");
				}
				if ($_ == "!done") {
					$receiveddone = TRUE;
				}
				$STATUS = socket_get_status($this->socket);
				if ($LENGTH > 0) {
					$this->log->message(__CLASS__, '>>> [' . $LENGTH . ', ' . $STATUS['unread_bytes'] . ']' . $_, "api");
				}
				if ((!$this->connected && !$STATUS['unread_bytes']) || ($this->connected && !$STATUS['unread_bytes'] && $receiveddone)) {
					break;
				}
			}
			if ($parse) {
				$RESPONSE = $this->parse_response($RESPONSE);
			}
			return $RESPONSE;
		}

		/* WRITE: */
		private function write($command, $param2 = TRUE) {
			if ($command) {
				$data = explode("\n", $command);
				foreach ($data as $com) {
					$com = trim($com);
					fwrite($this->socket, $this->encode_length(strlen($com)) . $com);
					$this->log->message(__CLASS__, '<<< [' . strlen($com) . '] ' . $com, "api");
				}
				if (gettype($param2) == 'integer') {
					fwrite($this->socket, $this->encode_length(strlen('.tag=' . $param2)) . '.tag=' . $param2 . chr(0));
					$this->log->message(__CLASS__, '<<< [' . strlen('.tag=' . $param2) . '] .tag=' . $param2, "api");
				} elseif (gettype($param2) == 'boolean') {
					fwrite($this->socket, ($param2 ? chr(0) : ''));
				}
				return TRUE;
			} else {
				return FALSE;
			}
		}

		/* RUN A COMMAND ON MIKROTIK: */
		private function command($command, $arr = array()) {
			$count = count($arr);
			$this->write($command, !$arr);
			$i = 0;
			foreach ($arr as $k => $v) {
				switch ($k[0]) {
					case "?":
						$el = "$k=$v";
						break;
					case "~":
						$el = "$k~$v";
						break;
					default:
						$el = "=$k=$v";
						break;
				}
				$last = ($i++ == $count - 1);
				$this->write($el, $last);
			}
			return $this->read();
		}

/* >> END OF MIKROTIK API << */





		/* GET AUTHORIZATION DATA FROM `nas_data.ini`: */
		private function get_auth_data($nasip) {
			$return = array();
			if (file_exists(BASEPATH . "nas_data.ini")) {
				$data = parse_ini_file(BASEPATH . "nas_data.ini", TRUE);
				if (array_key_exists($nasip, $data)) {
					$return = $data[$nasip];
				} else $this->log->message(__CLASS__, "Cannot get authorization data, entry for `" . $nasip . "` is absent!", "error");
			} else $this->log->message(__CLASS__, "Cannot get authorization data, `nas_data.ini` is absent!", "error");
			return $return;
		}

		/* GET ADDITIONAL NETWORK DATA FROM `network_data.ini`: */
		private function get_network_data($netid) {
			$return = NULL;
			if (file_exists(BASEPATH . "network_data.ini")) {
				$data = parse_ini_file(BASEPATH . "network_data.ini", TRUE);
				if (array_key_exists($netid, $data)) {
					$return = $data[$netid];
				} else $this->log->message(__CLASS__, "Cannot get network data, entry for `" . $netid . "` is absent!", "error");
			} else $this->log->message(__CLASS__, "Cannot get network data, `network_data.ini` is absent!", "error");
			return $return;
		}

		/* PUT RATE VALUES TO QUEUE TEMPLATE: */
		private function generate_rates($data) {
			if(!empty($data['REASSIGNED'])) {
				$this->template['QUEUE']['limit-at']	= $data['REASSIGNED'] . $this->config['rate_val'] . "/" . $data['REASSIGNED'] . $this->config['rate_val'];
				$this->template['QUEUE']['max-limit']	= $data['REASSIGNED'] . $this->config['rate_val'] . "/" . $data['REASSIGNED'] . $this->config['rate_val'];
			} elseif(!empty($data['TARIFF']['TX']) AND !empty($data['TARIFF']['RX'])) {
				$this->template['QUEUE']['limit-at']	= $data['TARIFF']['TX'] . $this->config['rate_val'] . "/" . $data['TARIFF']['RX'] . $this->config['rate_val'];
				$this->template['QUEUE']['max-limit']	= $data['TARIFF']['TX'] . $this->config['rate_val'] . "/" . $data['TARIFF']['RX'] . $this->config['rate_val'];
			} else {
				$this->template['QUEUE']['limit-at']	= 0 . $this->config['rate_val'] . "/" . 0 . $this->config['rate_val'];
				$this->template['QUEUE']['max-limit']	= 0 . $this->config['rate_val'] . "/" . 0 . $this->config['rate_val'];
			}
			return $this->template['QUEUE'];
		}
		
		/* PUT COMMAND FOR ADDRESS-LIST (DEPENDS OF ENVIRONMENT): */
		private function address_list()	{
			switch (ENVIRONMENT) {
				case "OnConnect":
					$this->template['ADDRESS_LIST']['disabled'] = "no";
					break;
				case "OnDisconnect":
					$this->template['ADDRESS_LIST']['disabled'] = "yes";
					break;
			}
			$props = $this->command("/ip/firewall/address-list/print", array(
				".proplist"	=>	".id",
				"?comment"	=>	LOGIN
			));
			if (!empty($props)) {
				foreach ($props as $property) {
					$this->template['ADDRESS_LIST']['.id'] = $property['.id'];
					$reply = $this->command("/ip/firewall/address-list/set", $this->template['ADDRESS_LIST']);
					if (empty($reply)) {
						$this->log->message(__CLASS__,  "Address List entry with ID - `" . $this->template['ADDRESS_LIST']['.id'] . "` was updated;", "success");
					} else {
						$this->log->message(__CLASS__,  "Cannot update Address List entry, " . $reply['!trap'][0]['message'] . "!", "error");
					}
				}
			} else {
				$reply = $this->command("/ip/firewall/address-list/add", $this->template['ADDRESS_LIST']);
				if (is_string($reply)) {
					$this->log->message(__CLASS__,  "New Address List entry was added with ID - `" . $reply . "`;", "success");
				} elseif ($reply['!trap'][0]['message']) {
					$this->log->message(__CLASS__,  "Cannot add new Address List entry, " . $reply['!trap'][0]['message'] . "!", "error");
				}
			}
		}

		/* PUT COMMAND FOR ARP: */
		private function arp($data) {
			$props = $this->command("/ip/arp/print", array(
				".proplist"	=>	".id",
				"?comment"	=>	LOGIN
			));
			if(!empty($props)) {
				foreach($props as $property) {
					$this->template['ARP']['.id'] = $property['.id'];
					$this->template['ARP']['mac-address']	= $data['MAC'];
					$this->template['ARP']['interface']		= $data['IFACE'];
					$reply = $this->command("/ip/arp/set", $this->template['ARP']);
					if (!$reply) {
						$this->log->message(__CLASS__,  "ARP entry with id - `" . $this->template['ARP']['.id'] . "` was updated;", "success");
					} else {
						$this->log->message(__CLASS__,  "Cannot update ARP entry, " . $reply['!trap'][0]['message'] . "!", "error");
					}
				}
			} else {
				$this->template['ARP']['mac-address']	= $data['MAC'];
				$this->template['ARP']['interface']		= $data['IFACE'];
				$reply = $this->command("/ip/arp/add", $this->template['ARP']);
				if (is_string($reply)) {
					$this->log->message(__CLASS__,  "New ARP entry was added with id - `" . $reply . "`;", "success");
				} elseif ($reply['!trap'][0]['message']) {
					$this->log->message(__CLASS__,  "Cannot add new ARP entry, " . $reply['!trap'][0]['message'] . "!", "error");
				}
			}
		}

		/* PUT COMMAND FOR QUEUE: */
		private function queue($data) {			
			$this->generate_rates($data);
			$props = $this->command("/queue/simple/print", array(
				".proplist"	=>	".id",
				"?name"		=>	LOGIN
			));
			if(!empty($props)) {
				foreach($props as $property) {					
					$this->template['QUEUE']['.id'] = $property['.id'];
					$reply = $this->command("/queue/simple/set", $this->template['QUEUE']);
					if (!$reply) {
						$this->log->message(__CLASS__,  "Queue entry with ID - `" . $this->template['QUEUE']['.id'] . "` was updated;", "success");
					} else {
						$this->log->message(__CLASS__,  "Cannot update Queue entry, " . $reply['!trap'][0]['message'] . "!", "error");
					}
				}
			} else {
				$reply = $this->command("/queue/simple/add", $this->template['QUEUE']);
				if (is_string($reply)) {
					$this->log->message(__CLASS__,  "New Queue entry was added with id - `" . $reply . "`;", "success");
				} elseif (!empty($reply['!trap'][0]['message'])) {
					$this->log->message(__CLASS__,  "Cannot add new Queue entry, " . $reply['!trap'][0]['message'] . "!", "error");
				}
			}
		}

		/* OnConnect: */
		public function OnConnect($data = NULL, $nasip) {
			if(!empty($nasip)) {
				$auth = $this->get_auth_data($nasip);
				if(!is_null($auth)) {
					$this->connect($nasip, $auth['api_port'], $auth['username'], $auth['password']);
					if($this->connected) {
						$this->address_list();
						$this->queue($data['RATE']);
						if(!is_null($data['MAC']) AND !is_null($data['NETID'])) {
							$network = $this->get_network_data($data['NETID']);
							if(!is_null($network)) {
								$this->arp(array(
									'MAC'	=>	$data['MAC'],
									'IFACE'	=>	$network['interface']
								));
							}
						}
					}
				}
			} else $this->log->message(__CLASS__,  "Cannot connect to MikroTik, any NAS IP was specified!", "error");
		}

		/* OnDisconnect: */
		public function OnDisconnect($data = NULL, $nasip) {
			if(!empty($nasip)) {
				$auth = $this->get_auth_data($nasip);
				if(!is_null($auth)) {
					$this->connect($nasip, $auth['api_port'], $auth['username'], $auth['password']);
					if($this->connected) {
						$this->address_list();
					}
				}
			} else $this->log->message(__CLASS__,  "Cannot connect to MikroTik, any NAS IP was specified!", "error");
		}
	}
?>